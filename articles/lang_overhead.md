---
title: "オーバーヘッドはプログラムの実行時間にどの程度影響を与えるのか？"
emoji: "🐺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [python3, C, C#, overhead]
published: false
---

> アドベントカレンダー（自称）vol.7

皆さん、こんにちは。yumyum116 です。SWE転職を目指す者です。
アドベントカレンダーに便乗して、1日1記事投稿に挑戦するとともに、執筆活動の習慣化にも挑戦してみます。

本記事は、頭休めになるような、それでいて、学びにもなるtipsを取り扱います。
コーヒー片手にお付き合いいただけますと幸いです。

## 1. プログラミング言語には "種類" がある話
さて、こちらの記事でも少し触れていますが、プログラミング言語には "種類" があります。

https://zenn.dev/yumyum116/articles/2313663b104678

どのような "種類" があるのかは、着目する観点で異なりますが、本記事では、`プログラミング言語の型付けのタイミング`の観点から、プログラミング言語を `静的型付け言語` と `動的型付け言語` に分類することにします。

両者の定義や違いの説明に移る前に、プログラムがどのように実行されるのか、について簡単に触れたいと思います。

ここで言う「プログラム」とは、エンジニアが、人間が理解できる形式で記述したソースコード群を指すことにします。
「プログラムが実行される」とは、
　　①プログラムをコンパイルして
　　②実行ファイルを生成し、
　　③生成された実行ファイルを実行する
ことです。

「コンパイルする」とは、プログラムを機械が理解できる言語（機械語）に翻訳する処理のことです。
「実行ファイルを生成する」とは、機械語に翻訳されたプログラムファイルを生成することです。

この流れで処理が行われる場合、①と②でそれぞれファイルが生成されますが、①と②を同時に実施してくれる仕組み（コンパイルが不要）もあります。
コンパイルが不要な仕組みのことを、`インタプリタ`と呼びます。

ちなみに、プログラミング言語をコンパイル型言語か、インタプリタ型言語か、で分類している記事も散見されるようですが、**一般にコンパイル型言語として知られている言語であっても、インタプリタとして動作させることが可能な場合がある（C や C# など）**ため、「コンパイル型」か「インタプリタ型」といった分類は、厳密には成立し得ないこともあるので、ご注意ください。



それでは、ここからいよいよ本題に移ります。

ざっくり分類すると、`静的型付け言語` は、**プログラムの中で、変数や関数に対して、あらかじめ扱うデータの型を明示的に定義する言語**で、`動的型付け言語`  は、**プログラムのコンパイル時にデータ型が決定される言語**です。

ソースコード上の見た目の違いは次のようになります。

```
# 静的型付け言語（C）
int number;
bool is_prime(int number)
{
	...
}


# 動的型付け言語（python）
number
def is_prime(number):
	....

```

さて、このソースコードの書き方の違いが、プログラムの実行時間にどのように影響するのでしょうか。
次章以降で深堀ります。


## 2. プログラムのオーバーヘッドとは
コンピュータの世界における「オーバーヘッド」とは、
　**本来の処理とは別に必要となる処理やコスト**
を指します。

具体的には、
　①処理時間の遅延
　②メモリやCPUなどの、リソースの不要な消費
　③データの送受信に付随して発生する追加処理
などに分けられます。

実務においては、実行環境の違いによる環境構築やコミュニケーションコストなども、広くオーバヘッドの概念に包含されますが、本記事ではプログラムの実行自体に直接的に関連するもののみをオーバーヘッドとして考えることとします。

さて、前章でご紹介した `静的型付け言語` と `動的型付け言語` を比較すると、後者の方がオーバーヘッドが大きいことが知られています。

分かりやすいところでは、`動的型付け言語` は、変数や関数の型をプログラム実行時に決定するため、プログラムの実行時間の中に **型チェック** のコストが余分にかかります。プログラムが大規模になればなるほど、この型チェックのコストが増大することは、想像に難くないでしょう。

`動的型付け言語`に分類されるpythonの場合は、この型チェックのコスト以外にも、GIL(Global Interpreter Lock)と呼ばれる、**一度に一つのスレッドしかpythonバイトコードを実行できない仕組み**があり、マルチコアCPUを活用した並列処理が制限されることなどもオーバーヘッドが大きくなる一因として知られています。

## 3. 実際に、プログラムの実行時間にどの程度影響があるのか
オーバーヘッドの違いによって、プログラムの実行時間がどの程度変わるのか、前回の記事[「素数を判定するプログラム」](https://zenn.dev/yumyum116/articles/math_uni_isprime)で紹介したプログラムを、python, C, C# でそれぞれ書き、それぞれのプログラムを10回実行した時の平均実行時間と標準偏差を比較してみました。

https://zenn.dev/yumyum116/articles/math_uni_isprime

その結果がこちらです。

![](/images/lang_overhead/benchmark_results.png)

実行時間を計測する際に、timeout = 3 としたため、is_prime_n.pyはタイムアウトにより実行時間が計測されていません。
他のプログラムで比較すると、Cが圧倒的に速いことが分かります。
C# はスクリプトとして実行できるようにしたため、その分オーバーヘッドが大きくなり、実行時間が長くなっています。
C#用の実行環境を構築し、その中で実行してあげると、0.04秒程度で実行してくれます。

最近は、pythonの実行速度を早めるための環境開発や、`Cython`と呼ばれる、pythonをC/C++に変換することで高速化を図る言語も開発されているようです。

pythonの実行に時間がかかる問題を解消するための技術開発等については、また後日取り上げたいと思います。

-----

記事内に誤謬等ある場合は、修正いたします。その際は、ご連絡いただけますと幸いです。

それでは、また。
