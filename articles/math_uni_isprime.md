---
title: "アルゴリズムの裏に潜む大学数学 \n
             vol.1 : 素数を判定する"
emoji: ":Wolf"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [python3, algorithm, prime, 素数]
published: false
---

> アドベントカレンダー（自称）vol.6

皆さん、こんにちは。yumyum116 です。SWE転職を目指す者です。
アドベントカレンダーに便乗して、1日1記事投稿に挑戦するとともに、執筆活動の習慣化にも挑戦してみます。

この記事は、`アルゴリズムの裏に潜む大学数学を紐解く`シリーズです。
アルゴリズムによって、アルゴリズムを支える数学が、高校数学だったり、大学以降で学習する内容だったり、大学数学の中でも大学３年生以上の専門分化以降で学習する内容だったりするので、数学のレベル別にトピックを分けてみます。
もちろん、自分が理解できる範囲の内容しか書けないので、記事の充足度に偏りが出ることは予めご承知おきください。

自分と同じようなところで躓いている方、プログラミング初学者の方の参考になれば嬉しいです。

シリーズ第1稿目は、自然数 $n$ が素数であるかどうかを判定するアルゴリズムの裏に潜む数学について紐解きます。

## 1. 自然数 $n$ が素数であるかどうかを判定するアルゴリズム

自然数 $n$ が素数であるかどうかを判定するプログラムを以下に示します。

```js:is_prime_n.py
def is_prime_n(n):
	if n <= 1:
		return False

	for i in range(2, n):
		if n % i == 0:
			return False

	return True
```

はい、とてもシンプルですね。
それでは、このプログラムの裏に潜む数学について考えてみます。


...というのは冗談で、上記のプログラムは時間計算量が $O(n)$ となり、$n$ の値が大きくなるほど計算量が増えるため、非常に効率が悪いです。

この時間計算量を改善したプログラムが以下のプログラムです。


```js:is_prime_sqrt.py
def is_prime(n):
	if n <= 1:
		return False

	for i in range(2, int(n ** 0.5) + 1):
		if n % i == 0:
			return False

	return True
```

こちらもとってもシンプルなプログラムです。時間計算量は $O(\sqrt{n})$ に短縮されました。
一見すると、はじめに紹介したプログラムと大きく変わっていないように見えます。

しかし、for文の繰り返し範囲に着目すると、そこには重要な性質が潜んでいるのです。

## 2. どのような数学的知識が必要なのか？
前章で記述した素数判定プログラム $is_prime.py$ は、次に示す性質を利用しています。

> 合成数 $a$ は、必ず $\sqrt{n}$ 以下の素因数 $b$ を持つ。

上記の性質は、一般に大学の整数論の中で取り扱われる内容ですが、競プロや数学オリンピックに親しんでいた方であれば、高校生の時点ですでに触れたことがあるかもしれません。

この性質は、背理法を用いて証明することができます。

背理法とは、

>　あることがら $P$ を示すのに、「$P$ が成り立たないと仮定し，そうすると矛盾が起こることを導く」ことにより，$P$ が成り立つことを証明する手法
[引用元](https://www.kyo-kai.co.jp/img/support/motto/motto15.pdf)

です。

それでは、証明してみましょう。

### 証明
合成数は、少なくとも二つ以上の素数の積で構成される。合成数を $N$, 素数を $p$, $q$ とおくと
$$
N >= p * q ...(1)
$$
である。

ここで、$\sqrt{N} < p$ かつ、$\sqrt{N} < q$ と仮定すると、$N < pq$ となり、(1) に反する。

したがって、$N > \sqrt{p}$ または $N > \sqrt{q}$ である。
（証明終）

この性質を利用することで、$2$ から $\sqrt{N}$ まで調べれば十分なのです。

## 3. さらに高速に素数判定を行うには
実は、第１章で紹介した is_prime 関数は、さらに高速化することができます。

高速化するための工夫は、`2から $\sqrt{N}$ の間に含まれる偶数を除く`ことです。
偶数はすべて２の倍数であり、素数ではないことが自明であるため、わざわざ確認する必要がない、という考え方です。

この考え方に基づく素数判定プログラムは、以下のように実装できます。

```js:is_prime_even.py
def is_prime(n):
	if n <= 1:
		return False
	if n == 2:
		return True

	for i in range(3, int(n ** 0.5) + 1):
		if n % i == 0:
			return False
		i += 2

	return True
```

繰り返し処理におけるインクリメント変数 $i$ の初期値を $3$ とし、インクリメントを $1$ ずつではなく、$2$ ずつとすることで、偶数を考慮せずに素数判定を行うことができます。


#### おまけ
本記事でご紹介した３つの異なる素数判定プログラムの実行時間を比較してみると、次のようになります。ちなみに、$n = 99999937$ とした時の実行時間です。
real(s) に出力されている時間が、プログラムを実行してから標準出力上に値が表示されるまでにかかる時間を示しています。

```
Program                        |  real(s) |  user(s) |   sys(s) |  max_rss(KB)
--------------------------------------------------------------------------------
is_prime_n.py                  |   44.774 |   44.459 |    0.040 |         9600
is_prime_sqrt.py               |    0.021 |    0.009 |    0.008 |         9344
is_prime_even.py               |    0.021 |    0.013 |    0.004 |         9216
```

後にご紹介した２つのアルゴリズムが、実行時間を大幅に短縮できていることがおわかりいただけたかと思います。
偶数を skip するプログラムは、期待していたほど高速化されなかったですね。もっと大きな値で比較できると差が出たかもしれませんが、`is_\prime.py` が TLE になるので、本記事の中では検証しません。気になる方は、お手元の環境で試してみてください。

ちなみに、大きく差が出るテストケースを考える上で、python3の面白い（？）特徴もまた一つ明らかになりました。後日、別記事でご紹介します。

-----

一見シンプルな実装になるプログラムでも、紐解いてみると数学の奥深い世界が見えてきます。
数字の性質を知っているだけで、計算量が大きく抑えられる点は非常に魅力的です。

記事内に、不適切な表現や誤謬等ございましたら、修正いたします。
その場合はご連絡いただけますと幸いです。

それでは、また。
