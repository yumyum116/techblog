---
title: "「何が分かると嬉しいのか？」を考えると、アルゴリズムが理解できるようになる話"
emoji: "🐺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [python3, algorithm, 二分探索, 最小の最大値]
published: false
---

> アドベントカレンダー（自称）vol.9

皆さん、こんにちは。yumyum116 です。SWE転職を目指す者です。
アドベントカレンダーに便乗して、1日1記事投稿に挑戦するとともに、執筆活動の習慣化にも挑戦してみます。

この記事は、やや応用のアルゴリズムになった途端に迷子になる自分が、**実際に躓いた箇所を元に、何に躓き、どのように理解できるようになったのか**について綴ります。
自分と同じようなところで躓いている方、プログラミング初学者の方の参考になれば嬉しいです。

今回は、二分探索で取り扱われる`最小の最大値`を求めるアルゴリズムについて取り上げます。

## 1. 1本の長いリボンを、$n$ 本以上に切り分ける場合に、最も短いリボンの長さが最大となる長さを求める
見出しのような問題を解くことを考えます。
ここでは、最終的に切り分けられる$n$本以上のリボンは、すべて同じ長さではなく、それぞれ長さが異なるものとします。

この問題を解くアルゴリズムは、二分探索の考え方を用いて、次のように書くことができます。

```js:calculate_max_of_min.py
def calculate_max_of_min(array, left, right, length, k):
	array.append(length)

	left = 0
	right = length + 1


	while right - left != 1:
		mid = (left + right) // 2

		last = 0
		count = 0

		for i in range(k + 1):
			if a[i] - last >= mid:
				last = a[i]
				count += 1

		if count >= n:
			left = mid
		else:
			right = mid

	return left

```

このプログラムを読んで、頭の中が混乱しなかった方は、おそらくこの記事でこれから述べる内容を十分に理解できていると思うので、他のことに時間をお使いください。

このプログラムを読んで、何をしているのか分からない、なぜ戻り値が left になるのか分からない、と思った方は、おそらくこの記事が何か有用なことを述べていると思いますので、お付き合いいただけますと幸いです。

## 2. 二分探索を理解する
本題に移る前に、本記事を読み進めるためには、二分探索をまず理解している必要があるので、二分探索について簡単に説明します。

二分探索とは、**探索範囲の中央の値を基準として、探索範囲を半々に狭めていくアルゴリズム**です。

ある問いに対する回答が Yes/No になるような場合に活用できます。
例えば、「高校に入学したのは2000年より前ですか、後ですか」といったような問いです。


実装方針としては、次のようになります。

　①探索範囲の左端と右端を変数で持つ。
　②探索範囲が十分に小さくなるまで、中央の値で条件を判定し、結果に応じて左端または右端を更新する。

より端的に表現するならば、二分探索とは、**ある条件を満たす境界値を求める**アルゴリズムです。


求めたい境界値を $k$ とした場合に、二分探索アルゴリズムは一般に次のように実装できます。

```
def binary_search(k):
	left = 0
	right = length

	while right - left > 1:
		mid = (left + right) // 2
		if array[mid] == k:
			return mid
		elif array[mid] > k:
			right = mid - 1
        elif array[mid] < k:
			left = mid + 1

	return -1

```

## 3. 分かると嬉しい値を考える
さて、問題に戻ります。

今回求めたい値は、「$n$本以上に切り分けられたリボンの中で、最も短いリボンの最大の長さ」でした。
この問題をどのように解くか？を考えます。

二分探索法について書いているので、二分探索法を使うんでしょ、と思われているかもしれませんが、ここで考えたいのは**二分探索法を使って解いた場合の戻り値がどのような値であると嬉しいのか**ということです。

一番の理想は、関数を実行した戻り値が、問題に対する解答になることだと思います。

この問題の場合は、関数 `calculate_max_of_min.py` の戻り値が、最も短いリボンの最大の長さになることです。

ここを理解できれば、本記事で述べたいことの7割は理解できています。


何を当然のことを話しているのか、と思われるかもしれませんが、私はしばらくここを理解できていませんでした。

初学者である私が、どのような関数を組み立てようとしていたかというと、次のような関数を考えていました。

　①リボンの左端から順に切っていき、切り分けられたリボンの長さを配列に格納する。
　②リボンの右端に達した時点で処理を止め、配列の要素数を数える。
　③②の値が$n$より小さい場合は、リボンを切る長さを短くして、①、②の処理を繰り返す
　④②の値が$n$となる時の、配列の要素の中で最小の値を求める

つまり、切り分けられたリボンの長さを格納している配列を返す関数を作成し、min関数の引数に関数の戻り値である配列を渡すことによって、切り分けられたリボンの最小の長さを求めようとしていたのです。

二分探索を使って解くことは重々承知していましたが、どのように考えると、二分探索が適用できるかが分からなかったので、半ば問題の意向を無視して解こうとしていました。


解答を見たときも、何が起こっているのかまったく理解できなかった記憶があります。
境界値 = mid と捉えていたので、戻り値が mid ではなく left の時点で、樹海に迷い込んだ気分でした。

その状態から、なぜこのアルゴリズムが理解できるようになったのかと言うと、**解答を得るためには、何が分かれば十分なのか**を考えたからです。

問われているのは、「切り分けられたリボンのうち、最小の長さのリボンの最大の長さ」であって、切り分けられたすべてのリボンの長さが分かっている必要はありません。解答となる長さ以外のリボンの長さを保持しておく必要もありません。


また、もう一つ着目すべき点があります。

それは、**切り分けられたリボンのうち、最小の長さとなるリボンがどこでも構わない**ということです。
すなわち、一番初めに切り取るリボンの長さを求めたい長さとしてしまえばよい、ということです。



さて、ようやく戻り値として返す値が決まりました。
次に、考えるのは、「切り分けられたリボンの中で最小の長さとなるリボンの長さが最大となる条件」を考えます。

これは言わずもがな、"切り分けられたリボンの数が $n$本になる時" で問題ないでしょう。

ここまで整理した上で、冒頭に書いたプログラムを改めて見てみましょう。

```js:calculate_max_of_min.py
def calculate_max_of_min(array, left, right, length, k):
	array.append(length)

	left = 0
	right = length + 1

	# 二分探索
	while right - left != 1:
		mid = (left + right) // 2

		last = 0
		count = 0

		for i in range(k + 1):
			if a[i] - last >= mid:
				last = a[i]
				count += 1

		if count >= n:
			left = mid
		else:
			right = mid

	return left

```

あら不思議。呪文のように見えていたプログラムが、急にシンプルでスマートなプログラムに見えてきました。
空間計算量の観点からも、バッチリです。

このプログラムでやっていたことは、**リボンを切り分ける$x$座標を二分探索により求めていた** ただそれだけなのです。

-----

まだまだ、アルゴリズムの設計力が弱いことを実感しているところではありますが、凝りずに少しずつ理解を深めていきたいと思います。

記事内に誤植等ございましたら、修正いたします。その際はご連絡いただけますと幸いです。

それでは、また。
